# 		java 内存模型（jmm）	
###1.什么是内存模型

​	 内存模型描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存中取出变量这样的底层细节，对象最终是存储在内存里面的，这点没有错，但是编译器、运行库、处理器或者[系统缓存](https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98/103044)可以有特权在变量指定内存位置存储或者取出变量的值。【JMM】（Java Memory Model的缩写）允许编译器和缓存以数据在处理器特定的缓存（或寄存器）和主存之间移动的次序拥有重要的特权，除非程序员使用了volatile或[synchronized](https://baike.baidu.com/item/synchronized/8483356)明确请求了某些可见性的保证。
###2.重排序
​	方法在执行过程中，可能不会按照书写的先后顺序就行执行，但是保证最终的结果与单机程序运行的结果是一致的即可。重排序只要为了提高性能。
​	内存级别的重排序会使程序的行为变得不可预测，如果没有同步，那么推断出执行的顺序将是非常困难的，而要确保在程序中正确地使用**同步**却是非常容易的。
 	简单来讲，重排序就是虚拟机会根据代码优化指令的执行顺序，以提高性能（在不影响最终结果的情况下）。
### 3.happens-before

​	为了不影响下最终结果，所以不能让jvm无限制的重排序，所以这里要遵循一些规则，强制的规定一些执行顺序。

**程序次序规则(Program Order Rule)**：在一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是代码顺序，因为要考虑分支、循环等结构。 
**监视器锁定规则(Monitor Lock Rule)**：一个unlock操作先行发生于后面对同一个对象锁的lock操作。这里强调的是同一个锁，而“后面”指的是时间上的先后顺序，如发生在其他线程中的lock操作。 
**volatile变量规则(Volatile Variable Rule)**:对一个volatile变量的写操作发生于后面对这个变量的读操作，这里的“后面”也指的是时间上的先后顺序。 
**线程启动规则(Thread Start Rule)**：Thread独享的start()方法先行于此线程的每一个动作。 
**线程终止规则(Thread Termination Rule)**：线程中的每个操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值检测到线程已经终止执行。 
**线程中断规则(Thread Interruption Rule)**：对线程interrupte()方法的调用优先于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否已中断。 
**对象终结原则(Finalizer Rule)**：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。 
**传递性(Transitivity)**：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 
